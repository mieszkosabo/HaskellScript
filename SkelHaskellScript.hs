-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelHaskellScript where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified AbsHaskellScript

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: AbsHaskellScript.Ident -> Result
transIdent x = case x of
  AbsHaskellScript.Ident string -> failure x

transUdent :: AbsHaskellScript.Udent -> Result
transUdent x = case x of
  AbsHaskellScript.Udent string -> failure x

transProgram :: Show a => AbsHaskellScript.Program' a -> Result
transProgram x = case x of
  AbsHaskellScript.Program _ stmts -> failure x

transBlock :: Show a => AbsHaskellScript.Block' a -> Result
transBlock x = case x of
  AbsHaskellScript.Block _ stmts -> failure x

transStmt :: Show a => AbsHaskellScript.Stmt' a -> Result
transStmt x = case x of
  AbsHaskellScript.Decl _ ident expr -> failure x
  AbsHaskellScript.FunDecl _ ident1 types ident2 expr -> failure x
  AbsHaskellScript.DataDecl _ udent typeargs constructors -> failure x
  AbsHaskellScript.Cond _ expr block -> failure x
  AbsHaskellScript.CondElse _ expr block1 block2 -> failure x
  AbsHaskellScript.Ret _ expr -> failure x
  AbsHaskellScript.VoidRet _ -> failure x
  AbsHaskellScript.Print _ exprs -> failure x
  AbsHaskellScript.Match _ ident cases -> failure x
  AbsHaskellScript.SExp _ expr -> failure x

transCase :: Show a => AbsHaskellScript.Case' a -> Result
transCase x = case x of
  AbsHaskellScript.Case _ expr block -> failure x

transType :: Show a => AbsHaskellScript.Type' a -> Result
transType x = case x of
  AbsHaskellScript.Int _ -> failure x
  AbsHaskellScript.Str _ -> failure x
  AbsHaskellScript.Bool _ -> failure x
  AbsHaskellScript.Void _ -> failure x
  AbsHaskellScript.FunT _ types -> failure x
  AbsHaskellScript.ListT _ type_ -> failure x
  AbsHaskellScript.WildcardT _ ident -> failure x
  AbsHaskellScript.DataType _ udent typeargs -> failure x

transTypeArg :: Show a => AbsHaskellScript.TypeArg' a -> Result
transTypeArg x = case x of
  AbsHaskellScript.TypeArg _ type_ -> failure x

transConstructor :: Show a => AbsHaskellScript.Constructor' a -> Result
transConstructor x = case x of
  AbsHaskellScript.Constructor _ udent typeargs -> failure x

transExpr :: Show a => AbsHaskellScript.Expr' a -> Result
transExpr x = case x of
  AbsHaskellScript.EVar _ ident -> failure x
  AbsHaskellScript.EConstr _ udent -> failure x
  AbsHaskellScript.ELitInt _ integer -> failure x
  AbsHaskellScript.EString _ string -> failure x
  AbsHaskellScript.ELitTrue _ -> failure x
  AbsHaskellScript.ELitFalse _ -> failure x
  AbsHaskellScript.Ternary _ expr1 expr2 expr3 -> failure x
  AbsHaskellScript.LongLambda _ idents block -> failure x
  AbsHaskellScript.ConciseLambda _ idents expr -> failure x
  AbsHaskellScript.Spread _ expr -> failure x
  AbsHaskellScript.ListExpr _ exprs -> failure x
  AbsHaskellScript.EApp _ expr exprs -> failure x
  AbsHaskellScript.Neg _ expr -> failure x
  AbsHaskellScript.Not _ expr -> failure x
  AbsHaskellScript.EMul _ expr1 mulop expr2 -> failure x
  AbsHaskellScript.EAdd _ expr1 addop expr2 -> failure x
  AbsHaskellScript.ERel _ expr1 relop expr2 -> failure x
  AbsHaskellScript.EAnd _ expr1 expr2 -> failure x
  AbsHaskellScript.EOr _ expr1 expr2 -> failure x

transAddOp :: Show a => AbsHaskellScript.AddOp' a -> Result
transAddOp x = case x of
  AbsHaskellScript.Plus _ -> failure x
  AbsHaskellScript.Minus _ -> failure x

transMulOp :: Show a => AbsHaskellScript.MulOp' a -> Result
transMulOp x = case x of
  AbsHaskellScript.Times _ -> failure x
  AbsHaskellScript.Div _ -> failure x
  AbsHaskellScript.Mod _ -> failure x

transRelOp :: Show a => AbsHaskellScript.RelOp' a -> Result
transRelOp x = case x of
  AbsHaskellScript.LTH _ -> failure x
  AbsHaskellScript.LE _ -> failure x
  AbsHaskellScript.GTH _ -> failure x
  AbsHaskellScript.GE _ -> failure x
  AbsHaskellScript.EQU _ -> failure x
  AbsHaskellScript.NE _ -> failure x
